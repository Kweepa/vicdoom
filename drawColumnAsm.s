;
; File generated by cc65 v 2.13.2
; then optimized (replaced)
;
	.fopt		compiler,"cc65 v 2.13.2"
	.setcpu		"6502X"
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp
	.export     _drawColumn
	.export     _drawColumnTransparent
	.export     _clearSecondBuffer
	.export     _copyToPrimaryBuffer
	.export     _clearFilled
	.export     _testFilled
	.export     _testFilledWithY
	.export     _setFilled

;
textures = $A000
bitmap = $1600
buffer = $BE00

.macro loadaxfromstack offs
	ldy #offs
	lda (sp),y
	tax
	dey
	lda (sp),y
.endmacro

; variables
tmp = $42
texIndex = $44
texI = $45
curX = $46
texY = $47
height = $49

.segment "DATA"

tmasktab:
.byte	$C0, $30, $0C, $03

filled_hi:
.res 32, 0
filled_lo:
.res 32, 0

shiftcode:

asl
rol
rol
nop

lsr
lsr
lsr
lsr

lsr
lsr
bit 0
; nop
; nop

bit 0
bit 0
;nop
;nop
;nop
;nop

;nop
;nop
bit 0
asl
asl

asl
asl
asl
asl

lsr
ror
ror
nop

.segment "LOWCODE"

.proc _clearFilled: near

lda #$7f
ldx #31
keepclearing:
sta filled_hi, x
sta filled_lo, x
dex
bpl keepclearing
rts

.endproc

.proc _testFilled: near

clc
adc #16
tax
lda filled_hi, x
rts

.endproc

.proc _setFilled : near

; AX holds y
; TOS holds x

sta tmp
ldy #0
lda (sp),y
clc
adc #16
tay
lda tmp
sta filled_lo,y
txa
sta filled_hi,y

ldy #1
jmp addysp

.endproc

.proc _testFilledWithY: near

; AX holds y
; TOS holds x

sta tmp
stx tmp+1
ldy #0
lda (sp),y
clc
adc #16
tay
sec
lda filled_lo,y
sbc tmp
lda filled_hi,y
sbc tmp+1

ldy #1
jmp addysp

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ drawColumn(char textureIndex, char texI, signed char curX, short curY, unsigned short h)
; ---------------------------------------------------------------
; param order is texIndex, texI, curX, curY (2), h (in AX)

;  if (h > 0)
;  {
;     // yStep = (TEXHEIGHT / 32) * curY / (SCREENHEIGHT / 8);
;     yStep = curY / 8;
;     texY = yStep / 2;
;
;     overage = h - HALFSCREENHEIGHT;
;     if (overage > 0)
;     {
;        h -= overage;
;        texY += overage * yStep;
;     }
;
;     // draw a column
;     curX += HALFSCREENWIDTH;

.proc _drawColumn: near

; clamp h to 255
cpx #0
beq hlessthan256
lda #255
hlessthan256:

; if (h > 0)
cmp #0
bne hnotzero
ldy #5
jmp addysp
hnotzero:

sta height

loadaxfromstack 1
; divide by 8 for yStep
sta stepLo+1
txa
lsr
ror stepLo+1
lsr
ror stepLo+1
lsr
ror stepLo+1
sta stepHi+1
; and divide by 2 for texY
ldx stepLo+1
stx texY
lsr
ror texY
sta texY+1

lda height
sec
sbc #32
bmi noadjust
beq noadjust
ldx #32
stx height
; multiply yStep by overage
ldx #0
jsr log2
sta tmp
stx tmp+1
lda stepLo+1
ldx stepHi+1
jsr log2
clc
adc tmp
tay
txa
adc tmp+1
clc
adc #8
tax
tya
jsr exp2
clc
adc texY
sta texY
tay
txa
adc texY+1
sta texY+1
tax
tya

noadjust:

ldy #2
lda (sp),y
clc
adc #16
sta curX

; modify screen mask code

and #$03
tax
lda tmasktab,x
eor #$ff
sta smask+1

iny
lda (sp),y
sta texI

; modify mask code
; now the mask is done before the shift to save using clc during the inner loop

and #$03
tax
lda tmasktab,x
sta tmask+1

iny
lda (sp),y
sta texIndex

;     screenAddr = buffer + SCREENHEIGHT*(curX/4) + (HALFSCREENHEIGHT - h);

lda curX
and #$1c
asl
asl
asl
rol
sta scrbuf+1
lda #>buffer
adc #0 ; plus carry
sta scrbuf+2
sta scrbuf2+2

lda #32 ; HALFSCREENHEIGHT
sec
sbc height
clc
adc scrbuf+1
sta scrbuf+1
sta scrbuf2+1

;     texAddr = textures + 128*textureIndex + TEXHEIGHT*(texI/4);

lda texI
and #$fc
asl
asl
asl
sta texAddr+1

lda texIndex
and #1
lsr
ror
ora texAddr+1
sta texAddr+1

lda texIndex
lsr
clc
adc #>textures
sta texAddr+2

; add texHi

lda texY+1
clc
adc texAddr+1
sta texAddr+1
lda texAddr+2
adc #0
sta texAddr+2

; just need to update the shifts now

lda curX
and #3
sta curX
lda texI
and #3
clc
adc #3
sec
sbc curX
asl
asl
tax

lda shiftcode,x
sta shiftcodegoeshere
lda shiftcode+1,x
sta shiftcodegoeshere+1
lda shiftcode+2,x
sta shiftcodegoeshere+2
lda shiftcode+3,x
sta shiftcodegoeshere+3

; number of pixels to draw in x
lda height
asl
tax
dex

; texLo is kept in y
ldy texY

clc
jmp insideloop

; cycles 2+2+2+4+2+4 +4+2+7+4+5+2+3
; approx 43 cycles per pixel
; so that's on average 32x32x43 per frame

loop:

tya
stepLo:
adc #0 ; self modified immediate operand
tay
lda texAddr+1
stepHi:
adc #0 ; self modified immediate operand
sta texAddr+1

insideloop:
texAddr:
lda textures ; self modified texture address
tmask:
and #0 ; self modified immediate operand
; shift into position for the screen
; modify these as required (asl/lsr/nop)
shiftcodegoeshere:
lsr
lsr
lsr
lsr
sta tmp
scrbuf:
lda buffer,x ; self modified screen addr
smask:
and #0
ora tmp
scrbuf2:
sta buffer,x ; self modified screen addr
dex
bpl loop

end:
ldy #5
jmp addysp

.endproc


; ---------------------------------------------------------------
; void __near__ __fastcall__ drawColumnTransparent(char textureIndex, char texYStart, char texYEnd, char texI, signed char curX, short curY, unsigned short h)
; ---------------------------------------------------------------
; param order is texIndex, texI, curX, curY (2), h (in AX)

;  if (h > 0)
;  {
;     // yStep = (TEXHEIGHT / 32) * curY / (SCREENHEIGHT / 8);
;     yStep = curY / 8;
;     texY = yStep / 2;
;
;     overage = h - HALFSCREENHEIGHT;
;     if (overage > 0)
;     {
;        h -= overage;
;        texY += overage * yStep;
;     }
;
;     // draw a column
;     curX += HALFSCREENWIDTH;

.proc _drawColumnTransparent: near

; clamp h to 255
cpx #0
beq hlessthan256
lda #255
hlessthan256:

; if (h > 0)
cmp #0
bne hnotzero
ldy #7
jmp addysp
hnotzero:

sta height

loadaxfromstack 1
; divide by 8 for yStep
sta stepLo+1
txa
lsr
ror stepLo+1
lsr
ror stepLo+1
lsr
ror stepLo+1
sta stepHi+1
; and divide by 2 for texY
ldx stepLo+1
stx texY
lsr
ror texY
sta texY+1

lda height
sec
sbc #32
bmi noadjust
beq noadjust
ldx #32
stx height
; multiply yStep by overage
ldx #0
jsr log2
sta tmp
stx tmp+1
lda stepLo+1
ldx stepHi+1
jsr log2
clc
adc tmp
tay
txa
adc tmp+1
clc
adc #8
tax
tya
jsr exp2
clc
adc texY
sta texY
tay
txa
adc texY+1
sta texY+1
tax
tya

noadjust:

ldy #2
lda (sp),y
clc
adc #16
sta curX

; modify screen mask code

and #$03
tax
lda tmasktab,x
eor #$ff
sta smask+1

iny
lda (sp),y
sta texI

; modify texture mask code

and #$03
tax
lda tmasktab,x
sta tmask+1

ldy #6
lda (sp),y
sta texIndex

;     screenAddr = buffer + SCREENHEIGHT*(curX/4) + (HALFSCREENHEIGHT - h);

lda curX
and #$1c
asl
asl
asl
rol
sta scrbuf+1
lda #>buffer
adc #0 ; plus carry
sta scrbuf+2
sta scrbuf2+2

lda #32 ; HALFSCREENHEIGHT
sec
sbc height
clc
adc scrbuf+1
sta scrbuf+1
sta scrbuf2+1

;     texAddr = textures + 128*textureIndex + TEXHEIGHT*(texI/4);

lda texI
and #$fc
asl
asl
asl
sta texAddr+1

lda texIndex
and #1
lsr
ror
ora texAddr+1
sta texAddr+1

lda texIndex
lsr
clc
adc #>textures ; start of texture memory
sta texAddr+2


; add texture offset
lda texAddr+1
clc
ldy #5
adc (sp),y
sta texAddr+1

; poke texture upper limit
ldy #4
lda (sp),y
clc
adc texAddr+1
sta texLimit+1

; add texHi

lda texY+1
clc
adc texAddr+1
sta texAddr+1
lda texAddr+2
adc #0
sta texAddr+2

; see if it's all off screen
lda texAddr+1
cmp texLimit+1
bmi :+
jmp end
:

; just need to update the shifts now

lda curX
and #3
sta curX
lda texI
and #3
clc
adc #3
sec
sbc curX
asl
asl
tax

lda shiftcode,x
sta shiftcodegoeshere
lda shiftcode+1,x
sta shiftcodegoeshere+1
lda shiftcode+2,x
sta shiftcodegoeshere+2
lda shiftcode+3,x
sta shiftcodegoeshere+3

; number of pixels to draw in x
lda height
asl
tax
dex

; texLo is kept in y
ldy texY

clc
jmp insideloop

loop:

tya
stepLo:
adc #0 ; self modified immediate operand
tay
lda texAddr+1
stepHi:
adc #0 ; self modified immediate operand
bcs end ; off the top of the texture
texLimit:
cmp #0 ; self modified immediate operand
bpl end ; off the end of the texture piece
sta texAddr+1

; cycles 4+2+2+2+2+2+4+5+2+2+2+2+2+2+4+2+4+3
; approx 48 cycles per pixel
; so that's on average 32x32x48 per frame
insideloop:
texAddr:
lda textures ; self modified texture address
; shift into position for the screen
; modify these as required (asl/lsr/nop)
tmask:
and #0 ; self modified immediate operand
beq dontWrite
shiftcodegoeshere:
lsr
lsr
lsr
lsr
sta tmp
scrbuf:
lda $1800,x
smask:
and #0 ; self modified immediate operand
ora tmp
scrbuf2:
sta $1800,x ; self modified screen addr
dontWrite:
dex
bpl loop

end:
ldy #7
jmp addysp

.endproc




.proc	_clearSecondBuffer: near

	ldx #63
	lda #0
clearLoop:
	sta buffer,x
	sta buffer + $40,x
	sta buffer + $80,x
	sta buffer + $C0,x
	sta buffer + $100,x
	sta buffer + $140,x
	sta buffer + $180,x
	sta buffer + $1C0,x
	dex
	bpl clearLoop
	rts

.endproc

.proc	_copyToPrimaryBuffer: near

	ldx #127
copyLoop:
	lda buffer,x
	sta bitmap,x
	lda buffer + $80,x
	sta bitmap + $80,x
	lda buffer + $100,x
	sta bitmap + $100,x
	lda buffer + $180,x
	sta bitmap + $180,x
	dex
	bpl copyLoop
	rts	

.endproc
